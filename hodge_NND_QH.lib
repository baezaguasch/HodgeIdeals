/*
Computation of Hodge Ideals for Newton non-degenerate (NND) 
and QH (quasihomogeneous) polynomials, implementing algorithms
from [Zha21] in Singular.

Last Update: 11-05-2024

Oriol Baeza Guasch (https://github.com/baezaguasch)	
Advisor: Josep Àlvarez Montaner
Facultat de Matemàtiques i Estadística
Universitat Politècnica de Catalunya 


References:
[Zha21] Mingyi Zhang. Hodge Ideals of Three Types of Isolated Hypersurface Singularities. 
	PhD thesis, Northwestern University, 2021. 
[Bla22] Guillem Blanco. An algorithm for Hodge ideals. 
	Mathematics of Computation, 91(338):2955–2967, 2022
*/

LIB "gfan.lib"; // newtonPolytope, facets (for Newton diagram)
LIB "dmod.lib"; // bernsteinBM (for BS roots)
LIB "hnoether.lib"; // is_NND (check if polynomial is NND)

// Auxiliary functions
// ##############################################################
proc dot_prod(intvec v1, intvec v2) {
    int m = size(v1);
    int res = 0;
    for (int i = 1; i <= m; i++) {
        res = res + v1[i] * v2[i];
    }
    return (res);
}

// Trick to convert bigint to int (required as polytope is given as bigint matrix)
proc big_to_int(bigint a) {
    poly pa = a;
    return (int(leadcoef(pa)));
}

// Check if polynomial is quasihomgeneous
proc is_quasihomog(poly g, int n_var) {
    // Input: polynomial f, number of variables n_var
    // Output: list with homogeneous weight and homogeneous degree if g is QH, else returns list = 0

    intvec w = qhweight(g);
    // If qhweight has a zero entry, then the polynomial is not quasihomogeneous
    int zero_entry = 0;
    int homog_degr;

    for (int j = 1; j <= n_var and zero_entry == 0; j++) {
        if (w[j] == 0) {
            zero_entry = 1;
        }
    }
    if (zero_entry == 1) {
        print("The polynomial is not quasihomogeneous :(");
        list L = 0;
    } else {
        homog_degr = dot_prod(leadexp(g), w);
        list L = w, homog_degr;

        link li = "";
        fprintf(li, "The polynomial is quasihomogeneous with weights: (%s),", L[1]);
        fprintf(li, "and homogeneous degree: %s %n", L[2], "");
    }
    return (L);
}

// ##############################################################

// Weight functions
// ##############################################################
proc w_deg(poly g, intvec homog_weight, int homog_degr) {
    // Input: polynomial g = sum_p a_p*x^p, weights homog_weight/homog_degr
    // Output: w-deg(g) = min{ <w,p> | a_p != 0 }

    int n_var = size(homog_weight);
    int res = 1000000;

    intvec lead_exp;
    poly lead_term;
    int curr_w;

    // Check through all monomials in g
    while (g != 0) {
        lead_exp = leadexp(g);
        curr_w = dot_prod(lead_exp, homog_weight);
        res = min(res, curr_w);

        lead_term = lead(g);
        g = g - lead_term;
    }

    return (number(res) / number(homog_degr));
}

proc rho_QH(poly g, intvec homog_weight, int homog_degr) {
    // Input: polynomial g, weights homog_weight/homog_degr
    // Output: rho(g) = |w| + w-deg(g)

    int total_weight = dot_prod(1: size(homog_weight), homog_weight);
    number w = number(total_weight) / number(homog_degr);
    return (w + w_deg(g, homog_weight, homog_degr));
}

proc rho_NND(poly g, bigintmat facets_f, int n_var) {
    // Input: polynomial g, Newton diagram facets
    // Output: rho~(g) = min_{s \in facets_f} { rho_{w^s}(g) }

    number res = 1000000;

    int n_facets = size(facets_f) div(n_var + 1);

    int homog_degr;
    intvec homog_weight;

    int i, j;
    for (i = 1; i <= n_facets; i++) {
        if (facets_f[i, 1] <= 0) {
            homog_degr = -big_to_int(facets_f[i, 1]);

            for (j = 1; j <= n_var; j++) {
                homog_weight[j] = big_to_int(facets_f[i, j + 1]);
            }
            res = min(res, rho_QH(g, homog_weight, homog_degr));
        }
    }
    return (res);
}
// ##############################################################

// Filtration on O given by rho
// ##############################################################

// Returns all lattice point required to generate O>=a. That is, it runs through the n_var dimensions, increasing
// each coordiante in order until it surpasses a weighted degree required, and saves this minimum generator
// as then, the ideal O>=a will be generated by this "first-surpassing" monomials.
// ie. find smallest lattice integer points above hyperplane, in the positive quadrant. 

proc get_lattice_points_QH(intvec homog_weight, intvec coord, number current_val, int index, number target) {
    list L;
    int n_var = size(coord);

    if (index == n_var) {
        int result = 0;
        while (current_val < target) {
            result++;
            current_val = current_val + homog_weight[n_var];
        }
        coord[n_var] = result;
        L = coord;
        
        coord[n_var] = 0;
        return (L);
    } else {
        // don't increase coord[index]
        L = L + get_lattice_points_QH(homog_weight, coord, current_val, index + 1, target);

        // increase coord[index] by 1
        number new_current_val = current_val;

        while (new_current_val < target) {
            coord[index] = coord[index] + 1;
            new_current_val = new_current_val + homog_weight[index];

            L = L + get_lattice_points_QH(homog_weight, coord, new_current_val, index + 1, target);
        }

        return (L);
    }
}

// O filtr
proc Ofiltr_QH(number beta, intvec homog_weight, int homog_degr) {
    int n_var = size(homog_weight);
    int total_weight = dot_prod(1: n_var, homog_weight);

    number target = beta * homog_degr - total_weight;

    list result_exps = get_lattice_points_QH(homog_weight, 0: n_var, 0, 1, target);
    int num_exps = size(result_exps);

    ideal I;
    for (int i = 1; i <= num_exps; i++) {
        I = std(I, monomial(result_exps[i]));
    }
    return (I);
}
// ##############################################################

// Filtration on O given by rho_NND
// ##############################################################

// Returns all lattice point required to generate O~>=a. That is, it runs through the n_var dimensions, increasing
// each coordiante in order until it surpasses a rho~ weighted degree required, and saves this minimum generator,
// so then the ideal O~>=a will be generated by this "first-surpassing" monomials

proc get_lattice_points_NND(bigintmat facets_f, intvec coord, int index, number target) {
    list L;
    int n_var = size(coord);

    if (index == n_var) {
        coord[n_var] = 0;
        number current_val = rho_NND(monomial(coord), facets_f, n_var);

        while (current_val < target) {
            coord[n_var] = coord[n_var] + 1;
            current_val = rho_NND(monomial(coord), facets_f, n_var);
        }
        L = coord;
        coord[n_var] = 0;
        return (L);
    } else {
        // don't increase coord[index]
        L = L + get_lattice_points_NND(facets_f, coord, index + 1, target);

        // increase coord[index] by 1
        number current_val = rho_NND(monomial(coord), facets_f, n_var);

        while (current_val < target) {
            coord[index] = coord[index] + 1;
            current_val = rho_NND(monomial(coord), facets_f, n_var);
            L = L + get_lattice_points_NND(facets_f, coord, index + 1, target);
        }

        return (L);
    }
}

// O~ filtr
proc Ofiltr_NND(number beta, bigintmat facets_f, int n_var) {

    list result_exps = get_lattice_points_NND(facets_f, 0: n_var, 1, beta);
    int num_exps = size(result_exps);

    ideal I;
    for (int i = 1; i <= num_exps; i++) {
        I = std(I, monomial(result_exps[i]));
    }
    return (I);
}
// ##############################################################

// Hodge ideals algorithms
// ##############################################################

// Quasihomogeneous
proc calculateHI_QH(number alpha, poly f, list weight_info, int n_var, int k_lim) {

    intvec homog_weight = weight_info[1]; 
    int homog_degr = weight_info[2]; 

    ideal Jf = std(jacob(f));
    ideal Mf = kbase(Jf);
    int mu = size(Mf);

    // rho(vj) for vj \in Mf = R/J(f)
    list rho_Mf = 0: mu;
    int j;
    for (j = 1; j <= mu; j++) {
        rho_Mf[j] = rho_QH(Mf[j], homog_weight, homog_degr);
    }

    ideal I0 = Ofiltr_QH(alpha, homog_weight, homog_degr);

    list HI;
    HI[1] = I0;

    ideal Iprev = I0;
    ideal Inext;

    int k, r, i;
    poly vj, e, g;

    for (k = 1; k <= k_lim; k++) {
        // calculate I_k
        Inext = 0;

        // sum Cvj, vj in Ofiltr >= alph+k
        for (j = 1; j <= mu; j++) {
            if (rho_Mf[j] >= number(k + alpha)) {
                Inext = std(Inext, Mf[j]);
            }
        }
        // sum Ox (f d_i(e) - (alpha+k-1) e d_i(f)), e in Ik-1, 1<=i<=n
        for (r = 1; r <= size(Iprev); r++) {
            e = Iprev[r];
            for (i = 1; i <= n_var; i++) {
                g = f * diff(e,
                    var (i)) - (a + k - 1) * e * diff(f,
                    var (i));
                Inext = std(Inext, g);
            }
        }

        Inext = stdfglm(Inext);
        HI[k + 1] = Inext;
        Iprev = Inext;
    }

    return (HI);
}

// Newton non-degenerate
proc calculateHI_NND(number alpha, poly f, bigintmat facets_f, int n_var, int k_lim) {

    ideal I0 = Ofiltr_NND(alpha, facets_f, n_var);

    list HI = I0;

    ideal Iprev = I0;
    ideal Inext;
    
    int k, r, i;
    poly vj, e, g;


    for (k = 1; k <= k_lim; k++) {
        // O~^{>=alpha + k}
        Inext = Ofiltr_NND(number(alpha + k), facets_f, n_var);
        
        // sum Ox (f d_i(e) - (alpha+k-1) e d_i(f)), e in Ik-1, 1<=i<=n
        for (r = 1; r <= size(Iprev); r++) {
            e = Iprev[r];
            for (i = 1; i <= n_var; i++) {
                g = f * diff(e,
                    var (i)) - (a + k - 1) * e * diff(f,
                    var (i));
                Inext = std(Inext, g);
            }
        }

        Inext = stdfglm(Inext);
        HI[k + 1] = Inext;
        Iprev = Inext;   	
    }

    return (HI); 
}
// ##############################################################

// Main functions
// ##############################################################

// Quasihomogeneous
proc hodgeIdeals_QH(poly f, int k_lim) {
    link li = "";

    fprintf(li, "Building extension ring with trascendental parameter alpha %n", "");
    def @R = basering;
    int n_var = nvars(@R);

    // Commutative (x_) ring with trascendental parameter 'a'.
    list RL = ringlist(@R);
    list RL1;
    if (size(RL[1]) == 0) { // no transcendental parameters in basering.
        RL1[1] = list(RL[1], list("a"), list(list("lp", 1)), ideal(0));
    } else { // trascendental parameters already in basering.
        RL1[1] = RL[1];
        RL1[1][2] = RL1[1][2] + list("a");
        RL1[1][3][1][2] = RL1[1][3][1][2], 1;
    }
    RL1[2] = RL[2]; //vars.
    RL1[3] = list(list("dp", 1: n_var), list("C", 0)); //orders.
    RL1[4] = RL[4]; //min. poly.
    // Make new ring non-commutative.
    ring @R2 = ring(RL1);
    setring(@R2);

    // Fetch polynomial to new ring
    //option(Imap);   
    poly f = fetch(@R, f);

    list weight_info = is_quasihomog(f, n_var); // homogeneous weights, total weight, homogeneous degree

    list BS = bernsteinBM(f);
    fprintf(li, "Calculating roots of Bernstein-Sato: {%s}", BS[1]);

    list jumping;
    number root;
    int i, j, repeated;
    for (i = 1; i <= size(BS[1]); i++) {
        // Shift roots to interval [-1,0)
        root = number(BS[1][i]);
        while (root < -1) {
            root = root + 1;
        }

        // Check collision with roots already shifted
        repeated = 0; // False
        for (j = 1; j <= size(jumping) and repeated == 0; j++) {
            if (-root == jumping[j]) {
                repeated = 1;
            }
        }
        // If shifted root is not yet in set, add it
        if (repeated == 0) {
            jumping[size(jumping) + 1] = -root;
        }
    }
    list sorted_jumping = sort(jumping)[1];
    fprintf(li, "Roots shifted %n", "");
    //print(sorted_jumping);

    list hodge;
    for (i = 1; i <= size(sorted_jumping); i++) {
        fprintf(li, "Calculating Hodge ideal for f^%s", sorted_jumping[i]);
        hodge[i] = list(sorted_jumping[i], calculateHI_QH(sorted_jumping[i], f, weight_info, n_var, k_lim));
    }

    fprintf(li, "%nResults:", "");
    print(hodge);

    export(hodge); return(@R2);
}

// Newton non-degenerate   
proc hodgeIdeals_NND(poly f, int k_lim) {
    link li = "";

    fprintf(li, "Building extension ring with trascendental parameter alpha %n", "");
    def @R = basering;
    int n_var = nvars(@R);

    // Commutative (x_) ring with trascendental parameter 'a'.
    list RL = ringlist(@R);
    list RL1;
    if (size(RL[1]) == 0) { // no transcendental parameters in basering.
        RL1[1] = list(RL[1], list("a"), list(list("lp", 1)), ideal(0));
    } else { // trascendental parameters already in basering.
        RL1[1] = RL[1];
        RL1[1][2] = RL1[1][2] + list("a");
        RL1[1][3][1][2] = RL1[1][3][1][2], 1;
    }
    RL1[2] = RL[2]; //vars.
    RL1[3] = list(list("dp", 1: n_var), list("C", 0)); //orders.
    RL1[4] = RL[4]; //min. poly.
    // Make new ring non-commutative.
    ring @R2 = ring(RL1);
    setring(@R2);

    // Fetch polynomial to new ring
    //option(Imap);   
    poly f = fetch(@R, f);

    polytope p = newtonPolytope(f);
    bigintmat facets_f = facets(p);
    print("Calculating Newton diagram of f:");
    print(p);

    list BS = bernsteinBM(f);
    fprintf(li, "Calculating roots of Bernstein-Sato: {%s}", BS[1]);

    list jumping;
    number root;
    int i, j, repeated;
    for (i = 1; i <= size(BS[1]); i++) {
        // Shift roots to interval [-1,0)
        root = number(BS[1][i]);
        while (root < -1) {
            root = root + 1;
        }

        // Check collision with roots already shifted
        repeated = 0; // False
        for (j = 1; j <= size(jumping) and repeated == 0; j++) {
            if (-root == jumping[j]) {
                repeated = 1;
            }
        }
        // If shifted root is not yet in set, add it
        if (repeated == 0) {
            jumping[size(jumping) + 1] = -root;
        }
    }
    list sorted_jumping = sort(jumping)[1];
    fprintf(li, "Roots shifted %n", "");
    //print(sorted_jumping);

    list hodge;
    for (i = 1; i <= size(sorted_jumping); i++) {
        fprintf(li, "Calculating Hodge ideal for f^%s", sorted_jumping[i]);
        hodge[i] = list(sorted_jumping[i], calculateHI_NND(sorted_jumping[i], f, facets_f, n_var, k_lim));
    }

    fprintf(li, "%nResults:", "");
    print(hodge);

    export(hodge); return(@R2);
}
// ##############################################################
